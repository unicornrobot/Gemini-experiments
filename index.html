<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5.js Serial Data Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        /* Basic styling for canvas */
        canvas {
            display: block;
            margin: 20px auto;
            border: 1px solid #ccc;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure buttons and controls are clearly visible and usable */
        button, select, input {
            padding: 8px 15px;
            margin: 5px;
            border-radius: 6px;
            border: 1px solid #ccc;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover, select:hover {
            background-color: #f0f0f0;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .status-indicator {
            padding: 10px;
            margin-top: 10px;
            border-radius: 6px;
            font-weight: bold;
        }
        .status-disconnected { background-color: #fecaca; color: #991b1b; } /* Red */
        .status-connected { background-color: #d1fae5; color: #065f46; } /* Green */
        .status-collecting { background-color: #bfdbfe; color: #1e40af; } /* Blue */
        .status-finished { background-color: #fef9c3; color: #854d0e; } /* Yellow */
        .status-error { background-color: #fed7aa; color: #9a3412; } /* Orange */
    </style>
</head>
<body class="bg-gray-100 p-5">

    <div class="container mx-auto max-w-4xl bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-bold mb-4 text-center text-gray-700">Serial Data Visualizer</h1>

        <div class="controls flex flex-wrap justify-center items-center gap-4 mb-4 p-4 bg-gray-50 rounded-md">
            <button id="connectButton" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-md shadow">Connect to Serial Device</button>

            <div class="flex items-center gap-2">
                <label for="collectDuration" class="text-sm font-medium text-gray-600">Collect for (seconds):</label>
                <input type="number" id="collectDuration" value="10" min="1" class="w-20 border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
            </div>

            <div class="flex items-center gap-1">
                <input type="checkbox" id="collectIndefinitely" class="rounded border-gray-300 text-indigo-600 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                <label for="collectIndefinitely" class="text-sm font-medium text-gray-600">Collect Indefinitely</label>
            </div>

            <button id="startButton" class="bg-green-500 hover:bg-green-600 text-white font-semibold rounded-md shadow" disabled>Start Collection</button>
            <button id="stopButton" class="bg-red-500 hover:bg-red-600 text-white font-semibold rounded-md shadow" disabled>Stop Collection</button>

            <div class="flex items-center gap-2">
                <label for="liveVizSelect" class="text-sm font-medium text-gray-600">Live View:</label>
                <select id="liveVizSelect" class="border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                    <option value="centeredStrips">Centered Strips</option>
                    <option value="particleEmitters">Particle Emitters</option>
                    <option value="wovenTapestry">Woven Tapestry</option>
                    <option value="wovenTapestryOverlay">Woven Tapestry (Overlay)</option>
                    <option value="none">None</option>
                    <!-- Add more live viz options here later -->
                </select>
            </div>

            <div class="flex items-center gap-2">
                <label for="vizSelect" class="text-sm font-medium text-gray-600">Final Visualization:</label>
                <select id="vizSelect" class="border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                    <option value="lines">Line Graph</option>
                    <option value="circles">Circular Plot</option>
                    <option value="radial">Radial Bars</option>
                    <option value="stackedBars">Stacked Bars</option>
                    <option value="histogram">Histogram (Stream 1)</option>
                    <option value="heatmap">Heatmap</option>
                </select>
            </div>

            <!-- Add Speed Slider Control -->
            <div id="overlaySpeedControl" class="flex items-center gap-2" style="display: none;"> <!-- Hidden initially -->
                 <label for="overlaySpeedSlider" class="text-sm font-medium text-gray-600">Overlay Speed:</label>
                 <input type="range" id="overlaySpeedSlider" min="0.1" max="5" value="1" step="0.1" class="w-32 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                 <span id="overlaySpeedValue" class="text-sm text-gray-500 w-8 text-right">1.0</span>
            </div>
            <!-- End Speed Slider Control -->

            <!-- Add Opacity Slider Control -->
            <div id="overlayOpacityControl" class="flex items-center gap-2" style="display: none;"> <!-- Hidden initially -->
                 <label for="overlayOpacitySlider" class="text-sm font-medium text-gray-600">Overlay Opacity:</label>
                 <input type="range" id="overlayOpacitySlider" min="0" max="1" value="0.7" step="0.05" class="w-32 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                 <span id="overlayOpacityValue" class="text-sm text-gray-500 w-8 text-right">0.7</span>
            </div>
            <!-- End Opacity Slider Control -->

        </div>

        <div id="status" class="status-indicator status-disconnected text-center mb-4">Status: Disconnected</div>
        <div id="errorDisplay" class="status-indicator status-error text-center mb-4" style="display: none;">Error: None</div>
        <div id="dataCount" class="text-center text-sm text-gray-500 mb-4">Data points collected: 0</div>


        <div id="canvasContainer" class="border rounded-md overflow-hidden shadow">
            </div>
    </div>

    <script>
        // --- Global Variables ---
        let port; // Serial port object
        let reader; // Serial port reader
        let keepReading = false; // Flag to control the reading loop
        let incomingBuffer = ''; // Buffer for incomplete serial lines

        let isCollecting = false; // Flag for data collection state
        let collectionStartTime;
        let collectionTimerId;
        let collectedData = []; // Array to store collected data [[val1, val2,...], [val1, val2,...]]
        let expectedDataLength = -1; // To store the number of values per line, determined by first valid data line
        let lastValidProgress = 0;
        let absoluteLatestData = null; // Store the very last parsed data line
        let collectIndefinitely = false; // Flag for indefinite collection
        let overlayDrawSpeed = 1.0; // Default drawing speed (pixels per frame)
        let overlayDrawAlpha = 0.7; // Default drawing alpha (0.0 to 1.0)
        let overlayCurrentY = -1; // Current drawing Y position for overlay (-1 indicates reset needed)

        let p5Instance; // To hold the p5 sketch instance
        let currentVisualization = 'lines'; // Default FINAL visualization
        let currentLiveVisualization = 'centeredStrips'; // Default LIVE visualization

        // --- UI Elements ---
        const connectButton = document.getElementById('connectButton');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const collectDurationInput = document.getElementById('collectDuration');
        const collectIndefinitelyCheckbox = document.getElementById('collectIndefinitely');
        const liveVizSelect = document.getElementById('liveVizSelect');
        const vizSelect = document.getElementById('vizSelect');
        const statusDiv = document.getElementById('status');
        const errorDiv = document.getElementById('errorDisplay');
        const dataCountDiv = document.getElementById('dataCount');
        const canvasContainer = document.getElementById('canvasContainer');
        const overlaySpeedControlDiv = document.getElementById('overlaySpeedControl');
        const overlaySpeedSlider = document.getElementById('overlaySpeedSlider');
        const overlaySpeedValueSpan = document.getElementById('overlaySpeedValue');
        const overlayOpacityControlDiv = document.getElementById('overlayOpacityControl');
        const overlayOpacitySlider = document.getElementById('overlayOpacitySlider');
        const overlayOpacityValueSpan = document.getElementById('overlayOpacityValue');

        // --- Utility Functions ---
        function updateStatus(message, type) {
            statusDiv.textContent = `Status: ${message}`;
            statusDiv.className = `status-indicator text-center mb-4 status-${type}`; // Update class for styling
        }

        function showError(message) {
            console.error(message);
            errorDiv.textContent = `Error: ${message}`;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            errorDiv.style.display = 'none';
        }

        function updateDataCount() {
            dataCountDiv.textContent = `Data points collected: ${collectedData.length}`;
        }

        function updateButtonStates() {
            const isConnected = port && port.readable;
            connectButton.disabled = isConnected;
            startButton.disabled = !isConnected || isCollecting;
            stopButton.disabled = !isCollecting;
            collectDurationInput.disabled = isCollecting;
            collectIndefinitelyCheckbox.disabled = isCollecting;
        }

        // --- Serial Communication ---
        async function connectSerial() {
            hideError();
            // Reset state variables in case of reconnection
            expectedDataLength = -1;
            absoluteLatestData = null;
            lastValidProgress = 0; // Reset progress too

            if ('serial' in navigator) {
                try {
                    updateStatus('Requesting port...', 'collecting');
                    port = await navigator.serial.requestPort();
                    await port.open({ baudRate: 9600 });

                    updateStatus('Connected', 'connected');
                    keepReading = true;
                    readLoop();
                    updateButtonStates();

                } catch (err) {
                    updateStatus('Connection failed', 'error');
                    showError(`Could not open port: ${err.message}`); // Adjusted error message slightly
                    port = null;
                    updateButtonStates();
                }
            } else {
                updateStatus('Web Serial API not supported', 'error');
                showError('Your browser does not support the Web Serial API. Try Chrome or Edge.');
            }
        }

        async function readLoop() {
            if (!port || !port.readable) {
                console.warn("Port not available or closed.");
                keepReading = false;
                updateStatus('Disconnected', 'disconnected');
                updateButtonStates();
                return;
            }

            // Use TextDecoderStream for easier text handling
            const textDecoder = new TextDecoderStream();
            const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();

            updateStatus('Reading data...', 'connected');

            try {
                while (keepReading) {
                    const { value, done } = await reader.read();
                    if (done) {
                        // Allow the serial port to be closed later.
                        reader.releaseLock();
                        break;
                    }
                    if (value) {
                        // Process the incoming chunk
                        processIncomingData(value);
                    }
                }
            } catch (error) {
                console.error('Error during reading:', error);
                showError(`Read error: ${error.message}`);
                updateStatus('Read error', 'error');
                // Attempt to clean up
                try {
                   await reader.cancel();
                   reader.releaseLock(); // Release lock on error
                } catch (cancelError) {
                    console.error('Error cancelling reader:', cancelError);
                }
                // Don't close the port here immediately, let disconnect handle it
                // await disconnectSerial(); // Maybe disconnect on read error?
            } finally {
                 // Ensure the lock is always released if the loop terminates unexpectedly
                if (reader && !reader.closed) {
                    try {
                        reader.releaseLock();
                    } catch(e) {
                        console.warn("Error releasing reader lock in finally:", e);
                    }
                }
            }
             // If keepReading became false, it means disconnect was called.
             // If the loop exited due to 'done', the port might have closed.
            if (!keepReading) {
                await disconnectSerial(); // Ensure cleanup if disconnect was initiated
            } else {
                 updateStatus('Reading stopped (port closed?)', 'disconnected');
                 updateButtonStates();
            }
        }

        function processIncomingData(chunk) {
            incomingBuffer += chunk;
            let newlineIndex;

            // Process buffer line by line
            while ((newlineIndex = incomingBuffer.indexOf('\n')) >= 0) {
                const line = incomingBuffer.substring(0, newlineIndex).trim(); // Get line, remove trailing \r if present
                incomingBuffer = incomingBuffer.substring(newlineIndex + 1); // Remove processed line from buffer

                if (line) { // Only process non-empty lines
                    parseAndStoreData(line);
                }
            }
            // Keep any remaining partial line in the buffer for the next chunk
        }

        function parseAndStoreData(line) {
            const threshold = 20;
            const padValue = 0;

            try {
                const values = line.split(',')
                                   .map(val => val.trim())
                                   .filter(val => val !== '')
                                   .map(Number);

                // --- Basic Format/Range Validation ---
                const isValidFormat = values.every(v => !isNaN(v) && v <= 360); // Allow negatives up to 360

                if (isValidFormat && values.length > 0) {
                    // Update absoluteLatestData with the raw parsed values
                    absoluteLatestData = values;

                    // --- Sensor Control for Overlay Viz ---
                    if (currentLiveVisualization === 'wovenTapestryOverlay' && values.length >= 12) {
                        const speedValue = values[10];
                        const newSpeed = p5Instance.map(speedValue, 0, 360, 0.1, 5.0);
                        overlayDrawSpeed = p5Instance.constrain(newSpeed, 0.1, 5.0);

                        const opacityValue = values[11];
                        const newAlpha = p5Instance.map(opacityValue, 0, 360, 0.0, 1.0);
                        overlayDrawAlpha = p5Instance.constrain(newAlpha, 0.0, 1.0);

                        if (overlaySpeedSlider && overlaySpeedValueSpan) {
                            overlaySpeedSlider.value = overlayDrawSpeed;
                            overlaySpeedValueSpan.textContent = overlayDrawSpeed.toFixed(1);
                        }
                        if (overlayOpacitySlider && overlayOpacityValueSpan) {
                             overlayOpacitySlider.value = overlayDrawAlpha;
                             overlayOpacityValueSpan.textContent = overlayDrawAlpha.toFixed(2);
                        }
                    }
                    // ------------------------------------

                    // Set expected length based on first valid line during collection
                     if (isCollecting && expectedDataLength === -1) {
                         expectedDataLength = values.length;
                         console.log(`Determined expected data length for this collection: ${expectedDataLength}`);
                     }
                } else {
                    console.warn("Invalid data format/range received:", line, values);
                    return;
                }
                // ---------------------------------------


                // --- Threshold Check & Data Storage Logic ---
                if (isCollecting) {
                    const meetsThreshold = values.some(v => v > threshold);
                    if (meetsThreshold) {
                        if (expectedDataLength === -1) {
                             expectedDataLength = values.length;
                             console.log(`Fallback: Determined expected data length for this collection: ${expectedDataLength}`);
                         }

                        let adjustedValues = [];
                         if (values.length === expectedDataLength) adjustedValues = values;
                         else if (values.length < expectedDataLength) { /* Pad */ adjustedValues = [...values]; while (adjustedValues.length < expectedDataLength) adjustedValues.push(padValue); console.warn(`Data line shorter. Padded. Line: "${line}"`); }
                         else { /* Truncate */ adjustedValues = values.slice(0, expectedDataLength); console.warn(`Data line longer. Truncated. Line: "${line}"`); }

                        collectedData.push(adjustedValues);
                        updateDataCount();

                        // *** Define durationMs HERE ***
                        const durationMs = parseInt(collectDurationInput.value, 10) * 1000;

                        // Update progress based on time (only if not indefinite)
                        if (durationMs > 0 && !collectIndefinitely) {
                            lastValidProgress = Math.min((Date.now() - collectionStartTime) / durationMs, 1);
                        }
                    }
                }
                // -------------------------------------------

            } catch (parseError) {
                 console.error("Error parsing line:", line, parseError);
            }
        }


        async function disconnectSerial() {
            keepReading = false;

            if (reader) {
                try {
                    await reader.cancel(); // Cancel any pending reads
                    // The releaseLock should happen in the readLoop's finally block
                } catch (err) {
                    console.error('Error cancelling reader:', err);
                    showError(`Error cancelling reader: ${err.message}`);
                }
                reader = null;
            }

            if (port && port.readable) {
                 // The read loop should release the lock. Wait a moment just in case.
                await new Promise(resolve => setTimeout(resolve, 100));
                try {
                    await port.close();
                    console.log("Serial port closed.");
                } catch (err) {
                    console.error('Error closing port:', err);
                     // Ignore errors if the port is already closed or closing.
                    if (!err.message.includes("port is already closed")) {
                       showError(`Error closing port: ${err.message}`);
                    }
                }
            }

            port = null;
            // Reset state variables on disconnect
            expectedDataLength = -1;
            absoluteLatestData = null;
            lastValidProgress = 0;
            updateStatus('Disconnected', 'disconnected');
            updateButtonStates();
        }


        // --- Data Collection ---
        function startCollection() {
            if (!port || !port.readable) {
                showError("Not connected to a serial device.");
                return;
            }
            if (isCollecting) return;

            hideError();
            collectedData = [];
            // Reset expected length for this specific collection run
            expectedDataLength = -1;
            lastValidProgress = 0;
            absoluteLatestData = null; // Clear latest data from previous run
            overlayCurrentY = -1; // Reset Y position marker
            updateDataCount();
            isCollecting = true;
            collectionStartTime = Date.now();

            let statusMessage = "";
            if (collectIndefinitely) {
                statusMessage = "Collecting data indefinitely...";
                updateStatus(statusMessage, 'collecting');
                // Do NOT set the timer
                clearTimeout(collectionTimerId);
                collectionTimerId = null; // Explicitly clear timer ID
            } else {
                const durationSeconds = parseInt(collectDurationInput.value, 10);
                const durationMs = durationSeconds * 1000;
                statusMessage = `Collecting data for ${durationSeconds}s...`;
                updateStatus(statusMessage, 'collecting');
                // Set the timer only if not indefinite
                clearTimeout(collectionTimerId);
                collectionTimerId = setTimeout(stopCollection, durationMs);
            }

            updateButtonStates(); // Update buttons after setting isCollecting

            // Prepare p5 canvas
            if (p5Instance) {
                 if (p5Instance.sketchInstanceVariables && typeof p5Instance.sketchInstanceVariables.clearParticles === 'function') {
                    p5Instance.sketchInstanceVariables.clearParticles();
                 }

                 // Set initial background based on selected live visualization
                 // Modes that don't clear per frame need an initial clear.
                 if (currentLiveVisualization === 'centeredStrips' || currentLiveVisualization === 'wovenTapestryOverlay') {
                     p5Instance.background(240);
                     if (currentLiveVisualization === 'wovenTapestryOverlay' && p5Instance.height) {
                         overlayCurrentY = p5Instance.height; // Initialize Y specifically for overlay
                     }
                 } else {
                     // For others (particles, standard tapestry, none), the background
                     // will be handled within their respective draw cases.
                     p5Instance.background(240); // General initial clear still okay
                 }

                 p5Instance.loop(); // Start the p5 draw loop
            }
        }

        function stopCollection() {
            if (!isCollecting) return; // Not collecting

            isCollecting = false;
            clearTimeout(collectionTimerId); // Clear timer in case stopped manually
            const collectionEndTime = Date.now();
            const actualDuration = ((collectionEndTime - collectionStartTime) / 1000).toFixed(1);

            updateStatus(`Collection finished (${actualDuration}s). ${collectedData.length} points captured.`, 'finished');
            updateButtonStates();

            // Stop the p5 draw loop and trigger a final draw for the selected post-collection visualization
            if (p5Instance) {
                p5Instance.noLoop();
                p5Instance.redraw(); // Redraw one last time with the selected visualization
            }
        }

        // --- P5 Sketch Definition ---
        const sketch = (p) => {
            let canvasWidth = 600;
            let canvasHeight = 400;

            // Store sketch-specific variables/functions needed externally
            // Note: This is a slight workaround for accessing sketch state from global functions
            p.sketchInstanceVariables = {
                 particles: [],
                 clearParticles: () => { p.sketchInstanceVariables.particles = []; }
            };
            let particles = p.sketchInstanceVariables.particles; // Local reference

            // Simple Particle class (or object structure)
            class Particle {
                constructor(x, y, vx, vy, lifespan, col) {
                    this.pos = p.createVector(x, y);
                    this.vel = p.createVector(vx, vy);
                    this.lifespan = lifespan; // Frames
                    this.initialLifespan = lifespan;
                    this.col = col; // p5.color object
                }

                update() {
                    this.pos.add(this.vel);
                    this.lifespan -= 1;
                }

                display() {
                    // Fade out as lifespan decreases
                    let alpha = p.map(this.lifespan, 0, this.initialLifespan, 0, 255);
                    // Use HSB components from the stored color, but adjust alpha
                    p.fill(p.hue(this.col), p.saturation(this.col), p.brightness(this.col), alpha / 255); // p5 alpha is 0-1 in HSB
                    p.noStroke();
                    p.ellipse(this.pos.x, this.pos.y, 8, 8); // Draw particle as a small circle
                }

                isDead() {
                    return this.lifespan <= 0;
                }
            }


            // Visualization functions are defined within the sketch scope
            const visualizations = {
                lines: (data) => {
                    p.stroke(0, 100, 200, 150); // Blueish lines
                    p.strokeWeight(1);
                    p.noFill();

                    if (data.length === 0 || data[0].length === 0) return; // No data

                    const numLines = data[0].length;
                    const spacing = p.width / (data.length -1 || 1); // Avoid division by zero if only 1 point

                    for (let j = 0; j < numLines; j++) {
                        p.beginShape();
                        for (let i = 0; i < data.length; i++) {
                            const x = i * spacing;
                            // Map data value (0-360) to canvas height (with padding)
                            const y = p.map(data[i][j] || 0, 0, 360, p.height - 20, 20); // Use || 0 for safety
                            p.vertex(x, y);
                        }
                        p.endShape();
                    }
                     // Draw axes/labels (optional)
                    p.stroke(150);
                    p.strokeWeight(0.5);
                    p.line(0, p.height - 20, p.width, p.height - 20); // X-axis (bottom)
                    p.line(0, 20, p.width, 20); // Top guide
                    p.textAlign(p.LEFT, p.CENTER);
                    p.noStroke();
                    p.fill(100);
                    p.text('0', 5, p.height - 20);
                    p.text('360', 5, 20);
                },

                circles: (data) => {
                    p.noStroke();
                    if (data.length === 0 || data[0].length === 0) return;

                    const numStreams = data[0].length;
                    const maxRadius = p.min(p.width, p.height) / 2 * 0.8; // Max radius for largest circle
                    const centerX = p.width / 2;
                    const centerY = p.height / 2;

                    // Use the *last* data point for the visualization
                    const lastDataPoint = data[data.length - 1];

                    for (let i = 0; i < numStreams; i++) {
                        const value = lastDataPoint[i] || 0;
                        const radius = p.map(value, 0, 360, 0, maxRadius);
                        // Assign different colors based on index
                        p.fill((i * 60) % 255, 150, 200, 100); // Vary hue, semi-transparent
                        p.ellipse(centerX, centerY, radius * 2, radius * 2);
                    }
                     // Add labels (optional)
                    p.fill(0);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text(`Last reading: ${lastDataPoint.map(v => v.toFixed(0)).join(', ')}`, centerX, p.height - 20);
                },
                radial: (data) => {
                    p.strokeWeight(2);
                    if (data.length === 0 || data[0].length === 0) return;

                    const numStreams = data[0].length;
                    const centerX = p.width / 2;
                    const centerY = p.height / 2;
                    const maxLen = p.min(p.width, p.height) / 2 * 0.8;
                    const angleStep = p.TWO_PI / data.length; // Angle per data point over time

                    for (let j = 0; j < numStreams; j++) {
                        // Assign color based on stream index
                        p.stroke((j * 70) % 360, 80, 70); // HSB color mode

                        for (let i = 0; i < data.length; i++) {
                            const value = data[i][j] || 0;
                            const len = p.map(value, 0, 360, 0, maxLen);
                            const angle = i * angleStep - p.HALF_PI; // Start from top

                            const x = centerX + p.cos(angle) * len;
                            const y = centerY + p.sin(angle) * len;

                            // Draw a line from center to point for each reading
                            p.line(centerX, centerY, x, y);
                        }
                    }
                },
                stackedBars: (data) => {
                    p.noStroke();
                    if (data.length === 0 || data[0].length === 0) return;

                    const numDataPoints = data.length;
                    const numStreams = data[0].length;
                    const barWidth = p.width / numDataPoints;
                    const maxPossibleTotalValue = numStreams * 360; // Assuming max value per sensor is 360

                    for (let i = 0; i < numDataPoints; i++) {
                        let currentY = p.height; // Start drawing from the bottom
                        let totalValue = 0;
                        // Calculate total value for this time step first
                        for (let j = 0; j < numStreams; j++) {
                            totalValue += data[i][j] || 0;
                        }

                        // Map the total value to the bar's total height
                        const totalBarHeight = p.map(totalValue, 0, maxPossibleTotalValue, 0, p.height);

                        // Now draw segments, scaling them relative to the totalBarHeight
                        let segmentStartY = p.height;
                        for (let j = 0; j < numStreams; j++) {
                            const value = data[i][j] || 0;
                            // Calculate segment height as a proportion of the totalBarHeight
                            const segmentHeight = (totalValue > 0) ? (value / totalValue) * totalBarHeight : 0;

                            // Assign color based on stream index (using HSB)
                            p.fill((j * (360 / (numStreams + 1))) % 360, 80, 90); // Spread hues

                            // Draw the rectangle segment
                            p.rect(i * barWidth, segmentStartY - segmentHeight, barWidth, segmentHeight);

                            // Update the starting Y for the next segment
                            segmentStartY -= segmentHeight;
                        }
                    }

                    // Optional: Add labels or legend
                    p.fill(50); // Dark grey text
                    p.textAlign(p.LEFT, p.TOP); // Align to top left
                    p.text(`Showing ${numDataPoints} time steps as stacked bars.`, 5, 5); // Position at top left
                },
                histogram: (data) => {
                    p.stroke(100); // Light grey border for bars
                    p.strokeWeight(0.5);
                    if (data.length === 0 || data[0].length === 0) {
                        p.fill(150);
                        p.noStroke();
                        p.textAlign(p.CENTER, p.CENTER);
                        p.text('No data for histogram.', p.width / 2, p.height / 2);
                        return;
                    }

                    const numBins = 12; // How many bins to divide 0-360 into (e.g., 12 bins of 30 degrees)
                    const binWidthValue = 360 / numBins; // The range of values each bin covers
                    let binCounts = new Array(numBins).fill(0); // Initialize counts to zero

                    // --- Data Processing: Count values into bins ---
                    // We'll analyze the *first* data stream (index 0)
                    for (let i = 0; i < data.length; i++) {
                        const value = data[i][0] || 0; // Get value from the first stream
                        // Ensure value is within expected range (clamp just in case)
                        const clampedValue = p.constrain(value, 0, 359.999); // Use 359.999 to keep 360 out of bounds for bin index calc
                        const binIndex = Math.floor(clampedValue / binWidthValue);
                        if (binIndex >= 0 && binIndex < numBins) {
                            binCounts[binIndex]++;
                        } else {
                             console.warn(`Value ${value} resulted in unexpected bin index ${binIndex}`);
                        }
                    }

                    // --- Drawing ---
                    let maxCount = 0;
                    for (let count of binCounts) {
                        if (count > maxCount) {
                            maxCount = count;
                        }
                    }

                    if (maxCount === 0) {
                         p.fill(150);
                         p.noStroke();
                         p.textAlign(p.CENTER, p.CENTER);
                         p.text('No data points found in the expected range for Stream 1.', p.width / 2, p.height / 2);
                         return;
                    }

                    const barWidthPixels = p.width / numBins;
                    p.fill(0, 80, 80); // Use HSB color (Reddish)

                    for (let b = 0; b < numBins; b++) {
                        // Map the count in this bin to a height on the canvas
                        // Map range [0, maxCount] to [0, p.height]
                        const barHeight = p.map(binCounts[b], 0, maxCount, 0, p.height);

                        const x = b * barWidthPixels;
                        const y = p.height - barHeight; // Y position starts from bottom

                        p.rect(x, y, barWidthPixels, barHeight);

                        // Optional: Add labels for bins
                        p.fill(50); // Dark text
                        p.noStroke();
                        p.textAlign(p.CENTER, p.BOTTOM);
                        const binStart = Math.round(b * binWidthValue);
                        const binEnd = Math.round((b + 1) * binWidthValue);
                        // Only draw label if bar has some width
                        if (barWidthPixels > 20) {
                             p.text(`${binStart}-${binEnd}`, x + barWidthPixels / 2, p.height - 5);
                        }
                         p.fill(0, 80, 80); // Reset fill for next bar
                         p.stroke(100); // Reset stroke for next bar
                    }

                     // Add overall title/info
                     p.fill(50);
                     p.noStroke();
                     p.textAlign(p.LEFT, p.TOP);
                     p.text(`Histogram of Stream 1 values (${data.length} points, max count: ${maxCount})`, 5, 5);
                },
                heatmap: (data) => {
                    p.noStroke(); // No borders for the cells initially
                    if (data.length === 0 || data[0].length === 0) {
                        p.fill(150);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.text('No data for heatmap.', p.width / 2, p.height / 2);
                        return;
                    }

                    const numTimeSteps = data.length;
                    const numStreams = data[0].length;

                    // Calculate the size of each cell to fit the canvas
                    const cellWidth = p.width / numTimeSteps;
                    const cellHeight = p.height / numStreams;

                    // --- Draw the heatmap cells ---
                    for (let i = 0; i < numTimeSteps; i++) { // Iterate through time (columns)
                        for (let j = 0; j < numStreams; j++) { // Iterate through streams (rows)
                            const value = data[i][j] || 0;

                            // Map the value (0-360) to a color hue (e.g., blue to red)
                            // Using HSB: Hue from 240 (blue) down to 0 (red)
                            const hue = p.map(value, 0, 360, 240, 0);
                            p.fill(hue, 90, 90); // Saturation and Brightness set to 90

                            // Calculate position
                            const x = i * cellWidth;
                            const y = j * cellHeight;

                            // Draw the rectangle cell
                            p.rect(x, y, cellWidth, cellHeight);
                        }
                    }

                    // --- Optional: Add labels or grid lines if cells are large enough ---
                    if (cellHeight > 15) { // Only add stream labels if cells are tall enough
                        p.fill(0); // Black text
                        p.textAlign(p.LEFT, p.CENTER);
                        p.textSize(p.constrain(cellHeight * 0.6, 8, 14)); // Scale text size
                        for (let j = 0; j < numStreams; j++) {
                            p.text(`S${j+1}`, 5, j * cellHeight + cellHeight / 2);
                        }
                    }
                     if (cellWidth > 30) { // Only add time labels if cells are wide enough
                         p.fill(0);
                         p.textAlign(p.CENTER, p.TOP);
                         p.textSize(p.constrain(cellWidth * 0.2, 8, 12));
                         for (let i = 0; i < numTimeSteps; i+= Math.max(1, Math.floor(numTimeSteps/10))) { // Label ~10 steps
                             p.text(`${i}`, i * cellWidth + cellWidth / 2, 5);
                         }
                     }

                     // Add overall title
                     p.fill(50);
                     p.noStroke();
                     p.textAlign(p.CENTER, p.BOTTOM);
                     p.textSize(12);
                     p.text(`Heatmap: ${numStreams} streams over ${numTimeSteps} time steps`, p.width / 2, p.height - 5);
                }
            };

            p.setup = () => {
                // Dynamically determine canvas size based on container?
                // For now, fixed size.
                canvasWidth = canvasContainer.offsetWidth > 100 ? canvasContainer.offsetWidth : 600; // Ensure minimum width
                canvasHeight = 400;
                let cnv = p.createCanvas(canvasWidth, canvasHeight);
                cnv.parent('canvasContainer'); // Attach canvas to the div
                p.colorMode(p.HSB, 360, 100, 100, 1.0); // Use HSB for easier color manipulation
                p.noLoop(); // Start paused
                p.background(0, 0, 10); // Dark background initially
                p.textAlign(p.CENTER, p.CENTER);
                p.fill(0, 0, 80);
                p.text('Connect device and collect data to visualize.', p.width / 2, p.height / 2);
                // Initialize overlay Y after canvas is created
                overlayCurrentY = p.height;
            };

            p.draw = () => {
                 particles = p.sketchInstanceVariables.particles; // Ensure local reference is up-to-date

                if (isCollecting) {
                    // --- Live Visualization Logic ---
                     // Check if we have *any* data collected *at all* yet
                     // We might draw warp threads even before the first valid point
                     let latestValidData = null;
                     if (collectedData.length > 0) {
                         latestValidData = collectedData[collectedData.length - 1];
                     }
                     // We also need expectedDataLength to know how many streams to expect
                     const numStreams = (expectedDataLength > 0) ? expectedDataLength : 1; // Default to 1 if not set

                     // Get duration for calculations below
                     const durationSeconds = parseInt(collectDurationInput.value, 10) || 1; // Default to 1s if invalid

                    // --- Select live visualization based on dropdown ---
                    switch (currentLiveVisualization) {
                        case 'centeredStrips':
                             // --- Centered Strips Logic ---
                             // Must have valid data to draw strips
                             if (!latestValidData || collectedData.length === 0) return;

                             // **NO p.background() call here**
                             const stripBoxHeight = 2;
                             const stripTopEdgeY = p.height - (collectedData.length * stripBoxHeight);

                             let stripTotalActualWidth = 0;
                             let stripActualBoxWidths = [];
                             const stripMaxBoxWidthPerStream = p.width / numStreams;
                            for (let j = 0; j < numStreams; j++) {
                                 const value = latestValidData[j] || 0;
                                 const boxWidth = p.map(value, 0, 360, 0, stripMaxBoxWidthPerStream);
                                 stripActualBoxWidths.push(boxWidth);
                                 stripTotalActualWidth += boxWidth;
                             }
                             let stripStartX = (p.width - stripTotalActualWidth) / 2;
                             let stripCurrentX = stripStartX;
                            p.noStroke();
                            for (let j = 0; j < numStreams; j++) {
                                 const value = latestValidData[j] || 0;
                                 const boxWidth = stripActualBoxWidths[j];
                                const hue = p.map(value, 0, 360, 240, 0);
                                p.fill(hue, 90, 90);
                                if (boxWidth > 0) {
                                     p.rect(stripCurrentX, stripTopEdgeY, boxWidth, stripBoxHeight);
                                 }
                                 stripCurrentX += boxWidth;
                             }
                             break; // End of centeredStrips case

                        case 'wovenTapestry':
                            // --- Woven Tapestry Logic (Full Width, Wrap-Around) ---
                            p.background(30, 30, 40); // Dark background each frame

                            const warpSpacing = 8;
                            const warpColor = p.color(0, 0, 40);
                            const weftHeight = 4; // Fixed height for stable wrapping calculation

                            // 1. Draw Warp Threads
                            p.stroke(warpColor);
                            p.strokeWeight(1);
                            for (let wx = warpSpacing / 2; wx < p.width; wx += warpSpacing) {
                                p.line(wx, 0, wx, p.height);
                            }

                            // 2. Draw Weft Rows (wrap around, draw only visible)
                            p.noStroke();
                            if (collectedData.length > 0 && weftHeight > 0) {
                                const maxVisibleRows = Math.floor(p.height / weftHeight);
                                // Calculate the starting index in collectedData to draw
                                const startIndex = Math.max(0, collectedData.length - maxVisibleRows);

                                // Loop only through the data points that should be visible
                                for (let k = startIndex; k < collectedData.length; k++) {
                                    const dataPoint = collectedData[k];
                                    if (!dataPoint || dataPoint.length !== numStreams) continue;

                                    // Calculate the index relative to the visible window
                                    const relativeIndex = k - startIndex;
                                    // Calculate Y position based on relative index
                                    const rowY = p.height - (relativeIndex + 1) * weftHeight;

                                    // --- Calculate Proportional Widths ---
                                    let totalValueForRow = 0;
                                    for (let j = 0; j < numStreams; j++) {
                                        totalValueForRow += dataPoint[j] || 0;
                                    }

                                    let rowCurrentX = 0; // Start from left edge

                                    // Draw segments proportionally across the full width
                                    for (let j = 0; j < numStreams; j++) {
                                        const value = dataPoint[j] || 0;
                                        let proportionalWidth = 0;

                                        if (totalValueForRow > 0) {
                                            proportionalWidth = (value / totalValueForRow) * p.width;
                                        } else if (numStreams > 0) {
                                            proportionalWidth = p.width / numStreams;
                                        }

                                        // Map value to color and alpha
                                        const hue = p.map(value, 0, 360, 0, 360);
                                        const saturation = p.map(value, 0, 360, 40, 90);
                                        const brightness = p.map(value, 0, 360, 50, 95);
                                        const alpha = p.map(value, 0, 360, 0.5, 1.0);

                                        if (totalValueForRow === 0) {
                                            p.fill(0, 0, 50, 0.7);
                                        } else {
                                            p.fill(hue, saturation, brightness, alpha);
                                        }

                                        if (proportionalWidth > 0) {
                                            // Ensure drawing doesn't go below 0 due to float errors
                                            if (rowY >= 0) {
                                                 p.rect(rowCurrentX, rowY, proportionalWidth, weftHeight);
                                            }
                                        }
                                        rowCurrentX += proportionalWidth;
                                    }
                                }
                             } // End if collectedData.length > 0
                            break; // End of wovenTapestry case


                         case 'particleEmitters':
                              // --- Particle Emitter Logic ---
                              // This logic still runs every frame based on the *absolute latest* data
                              // received (via parseAndStoreData triggering redraw indirectly),
                              // regardless of the threshold, as it doesn't rely on collectedData history.
                              // Fetch the absolute latest data point processed (careful if parsing is slow)
                              // We need a way to get the *very* last parsed line, not just the last *stored* one.
                              // Let's modify parseAndStoreData slightly to store the absolute latest line.

                              // *** Need to adjust parseAndStoreData and add a new global variable ***
                              // *** See adjustment below ***

                              p.background(0, 0, 10, 0.1); // Trail effect

                              if (!absoluteLatestData || (expectedDataLength > 0 && absoluteLatestData.length !== expectedDataLength)) {
                                  break; // Check length against expected if known
                              }

                              const numEmitterStreams = absoluteLatestData.length;

                              for (let j = 0; j < numEmitterStreams; j++) {
                                  const value = absoluteLatestData[j] || 0; // Use absolute latest
                                  // ... (rest of emitter calculations: emitterX, Y, rate, hue, etc.) ...
                                   const emitterX = p.map(j, 0, numEmitterStreams - 1 || 1, p.width * 0.1, p.width * 0.9);
                                   const emitterY = p.height / 2;
                                   const emissionRate = p.map(value, 0, 360, 0, 3);
                                   const hue = p.map(value, 0, 360, 240, 0);
                                   const col = p.color(hue, 90, 90);
                                   const initialSpeed = 2;
                                   const lifespan = 80;

                                for (let i = 0; i < emissionRate; i++) {
                                       // ... (create particles) ...
                                        let angle = p.random(p.TWO_PI);
                                    let vx = p.cos(angle) * initialSpeed;
                                    let vy = p.sin(angle) * initialSpeed;
                                        p.sketchInstanceVariables.particles.push(new Particle(emitterX, emitterY, vx, vy, lifespan, col));
                                   }
                              }

                              // Update and display all particles
                              for (let i = p.sketchInstanceVariables.particles.length - 1; i >= 0; i--) {
                                  // ... (update, display, remove particles) ...
                                   p.sketchInstanceVariables.particles[i].update();
                                   p.sketchInstanceVariables.particles[i].display();
                                   if (p.sketchInstanceVariables.particles[i].isDead()) {
                                       p.sketchInstanceVariables.particles.splice(i, 1);
                                   }
                              }
                              break; // End of particleEmitters case

                        case 'wovenTapestryOverlay':
                            // --- Woven Tapestry (Overlay/Wrap) Logic with Speed & Opacity Control ---
                            // **NO p.background() call here**
                            if (!latestValidData || collectedData.length === 0) return;
                            if (numStreams <= 0) break;

                            const overlayWeftHeight = 4;
                            if (overlayWeftHeight <= 0) break;
                            const maxVisibleRows = Math.floor(p.height / overlayWeftHeight);
                            if (maxVisibleRows <= 0) break;

                            // --- Update and Wrap Y Position ---
                            if (overlayCurrentY === -1) overlayCurrentY = p.height;
                            overlayCurrentY -= overlayDrawSpeed;
                            if (overlayCurrentY < 0) overlayCurrentY = p.height;
                            const currentDrawY = Math.round(overlayCurrentY);

                            // --- Calculate Proportional Widths ---
                            let totalValueForRowOverlay = 0;
                            for (let j = 0; j < numStreams; j++) totalValueForRowOverlay += latestValidData[j] || 0;

                            let rowCurrentXOverlay = 0;
                            p.noStroke();
                            for (let j = 0; j < numStreams; j++) {
                                const value = latestValidData[j] || 0;
                                let proportionalWidthOverlay = 0;
                                if (totalValueForRowOverlay > 0) proportionalWidthOverlay = (value / totalValueForRowOverlay) * p.width;
                                else proportionalWidthOverlay = p.width / numStreams;

                                // Map value to color components (H, S, B)
                                const hueOverlay = p.map(value, 0, 360, 0, 360);
                                const saturationOverlay = p.map(value, 0, 360, 40, 90);
                                const brightnessOverlay = p.map(value, 0, 360, 50, 95);
                                // ** Use the global overlayDrawAlpha set by the slider **
                                const alphaOverlay = overlayDrawAlpha;

                                if (totalValueForRowOverlay === 0) {
                                    // Apply global alpha to the default fill too
                                    p.fill(0, 0, 50, alphaOverlay);
                                } else {
                                    p.fill(hueOverlay, saturationOverlay, brightnessOverlay, alphaOverlay);
                                }

                                if (proportionalWidthOverlay > 0 && currentDrawY >= 0) {
                                    p.rect(rowCurrentXOverlay, currentDrawY - overlayWeftHeight,
                                           proportionalWidthOverlay, overlayWeftHeight);
                                }
                                rowCurrentXOverlay += proportionalWidthOverlay;
                            }
                            break; // End of wovenTapestryOverlay case

                        case 'none':
                             p.background(240); // Clear background
                             p.noStroke();
                             p.fill(0, 0, 80);
                             // Only show progress bar if NOT indefinite
                             if (!collectIndefinitely) {
                                 const durationMs = parseInt(collectDurationInput.value, 10) * 1000 || 1;
                                 const timeProgress = p.constrain((Date.now() - collectionStartTime) / durationMs, 0, 1);
                                 p.rect(0, p.height - 5, p.width, 5); // Background bar
                                 p.fill(120, 80, 80);
                                 p.rect(0, p.height - 5, p.width * timeProgress, 5); // Progress
                             } else {
                                 // Maybe show a blinking indicator or just nothing for indefinite 'none'
                                 p.fill(150);
                                 p.textAlign(p.CENTER, p.BOTTOM);
                                 p.text("Collecting indefinitely...", p.width / 2, p.height - 10);
                             }
                             break; // End of none case

                        default:
                            // ... (default case with background clear) ...
                            p.background(240);
                            p.fill(0);
                            p.textAlign(p.CENTER, p.CENTER);
                            p.text(`Unknown live viz: ${currentLiveVisualization}`, p.width/2, p.height/2);

                     } // End switch

                } else if (collectedData.length > 0) {
                     // --- Post-Collection Logic ---
                    p.background(255); // Clear background for final visualization
                    if (visualizations[currentVisualization]) {
                        try {
                            visualizations[currentVisualization](collectedData);
                        } catch(visError) {
                             console.error(`Error in visualization '${currentVisualization}':`, visError);
                             p.fill(255,0,0); // Red for error
                             p.noStroke();
                             p.textAlign(p.CENTER, p.CENTER);
                             p.text(`Error rendering visualization: ${visError.message}`, p.width/2, p.height/2);
                        }
                    } else {
                        p.fill(200, 0, 0); // Indicate error - unknown viz
                        p.noStroke();
                        p.textAlign(p.CENTER, p.CENTER);
                        p.text(`Unknown visualization: ${currentVisualization}`, p.width / 2, p.height / 2);
                    }
                } else {
                    // --- Initial State Logic ---
                    p.background(0, 0, 10); // Dark background before connection/collection
                    p.fill(0, 0, 80);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text('Connect device and collect data to visualize.', p.width / 2, p.height / 2);
                }
            }; // End p.draw

             // Custom function to clear canvas, called before starting collection
            p.clearCanvas = () => {
                p.background(255); // Clear with white
                p.fill(180);
                p.noStroke();
                p.textAlign(p.CENTER, p.CENTER);
                p.text('Ready to collect data...', p.width / 2, p.height / 2);
                // p.redraw(); // Redraw immediately to show the cleared state
            };

            // Optional: Handle window resize
            p.windowResized = () => {
                 canvasWidth = canvasContainer.offsetWidth > 100 ? canvasContainer.offsetWidth : 600;
                 p.resizeCanvas(canvasWidth, canvasHeight); // Adjust height if needed too
                 // Don't redraw if collecting, let the loop handle it
                 if (!isCollecting) {
                    p.redraw();
                 }
            };
        };

        // --- Event Listeners ---
        connectButton.addEventListener('click', async () => {
            if (port) {
                await disconnectSerial(); // Disconnect if already connected (button logic should prevent this state ideally)
            } else {
                await connectSerial();
            }
             // Re-initialize p5 if needed, or ensure it's ready
            if (!p5Instance) {
                 p5Instance = new p5(sketch);
            } else {
                 // If p5 already exists, maybe reset background/state
                 p5Instance.background(0, 0, 10);
                 p5Instance.fill(0, 0, 80);
                 p5Instance.textAlign(p5Instance.CENTER, p5Instance.CENTER);
                 p5Instance.text('Connect device and collect data to visualize.', p5Instance.width / 2, p5Instance.height / 2);
                 p5Instance.noLoop(); // Ensure it's paused
            }
        });

        // Ensure the global startCollection is called
        startButton.addEventListener('click', startCollection); // No arrow func needed now
        stopButton.addEventListener('click', stopCollection);

        liveVizSelect.addEventListener('change', (event) => {
            currentLiveVisualization = event.target.value;
            // Show/hide the overlay controls based on selection
            const showOverlayControls = currentLiveVisualization === 'wovenTapestryOverlay';
            overlaySpeedControlDiv.style.display = showOverlayControls ? 'flex' : 'none';
            overlayOpacityControlDiv.style.display = showOverlayControls ? 'flex' : 'none'; // Toggle opacity control too

            if (showOverlayControls) {
                // When switching TO overlay, reset Y pos immediately
                overlayCurrentY = p5Instance ? p5Instance.height : -1;
            }

            // Clear background if switching TO a mode that needs it
            if (isCollecting && p5Instance && (currentLiveVisualization === 'particleEmitters' || currentLiveVisualization === 'wovenTapestry' || currentLiveVisualization === 'none')) {
                p5Instance.background(240);
            }
        });

        vizSelect.addEventListener('change', (event) => {
            currentVisualization = event.target.value;
            if (p5Instance && collectedData.length > 0 && !isCollecting) {
                p5Instance.redraw(); // Redraw with the new visualization if data exists and not collecting
            } else if (p5Instance && !isCollecting) {
                 // Optionally clear or show default message if no data
                 p5Instance.clearCanvas(); // Or redraw to show 'no data' message for the new viz type
                 p.background(255);
                 p.fill(180);
                 p.noStroke();
                 p.textAlign(p.CENTER, p.CENTER);
                 p.text(`Switched to ${currentVisualization}. Collect data to view.`, p.width / 2, p.height / 2);

            }
        });

        collectIndefinitelyCheckbox.addEventListener('change', (event) => {
            collectIndefinitely = event.target.checked;
            collectDurationInput.disabled = collectIndefinitely; // Disable duration if indefinite
            // Maybe add visual feedback like greying out the duration input/label
             if (collectIndefinitely) {
                 collectDurationInput.parentElement.classList.add('opacity-50');
             } else {
                 collectDurationInput.parentElement.classList.remove('opacity-50');
             }
        });

        // Add listener for the speed slider
        overlaySpeedSlider.addEventListener('input', (event) => {
            overlayDrawSpeed = parseFloat(event.target.value);
            overlaySpeedValueSpan.textContent = overlayDrawSpeed.toFixed(1);
        });

        // Add listener for the opacity slider
        overlayOpacitySlider.addEventListener('input', (event) => {
            overlayDrawAlpha = parseFloat(event.target.value);
            overlayOpacityValueSpan.textContent = overlayDrawAlpha.toFixed(2); // Update display
        });

        // Initial Setup
        updateButtonStates();
        // Hide overlay controls initially
        overlaySpeedControlDiv.style.display = 'none';
        overlayOpacityControlDiv.style.display = 'none';
        // Initialize slider text displays
        overlaySpeedValueSpan.textContent = parseFloat(overlaySpeedSlider.value).toFixed(1);
        overlayOpacityValueSpan.textContent = parseFloat(overlayOpacitySlider.value).toFixed(2);
        // Set initial state of duration input based on checkbox (in case of page reload)
        collectIndefinitelyCheckbox.dispatchEvent(new Event('change'));

    </script>

</body>
</html>
