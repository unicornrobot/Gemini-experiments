<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5.js Serial Data Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        /* Basic styling for canvas */
        canvas {
            display: block;
            margin: 20px auto;
            border: 1px solid #ccc;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure buttons and controls are clearly visible and usable */
        button, select, input {
            padding: 8px 15px;
            margin: 5px;
            border-radius: 6px;
            border: 1px solid #ccc;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover, select:hover {
            background-color: #f0f0f0;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .status-indicator {
            padding: 10px;
            margin-top: 10px;
            border-radius: 6px;
            font-weight: bold;
        }
        .status-disconnected { background-color: #fecaca; color: #991b1b; } /* Red */
        .status-connected { background-color: #d1fae5; color: #065f46; } /* Green */
        .status-collecting { background-color: #bfdbfe; color: #1e40af; } /* Blue */
        .status-finished { background-color: #fef9c3; color: #854d0e; } /* Yellow */
        .status-error { background-color: #fed7aa; color: #9a3412; } /* Orange */
    </style>
</head>
<body class="bg-gray-100 p-5">

    <div class="container mx-auto max-w-4xl bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-bold mb-4 text-center text-gray-700">Serial Data Visualizer</h1>

        <div class="controls flex flex-wrap justify-center items-center gap-4 mb-4 p-4 bg-gray-50 rounded-md">
            <button id="connectButton" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-md shadow">Connect to Serial Device</button>

            <div class="flex items-center gap-2">
                <label for="collectDuration" class="text-sm font-medium text-gray-600">Collect for (seconds):</label>
                <input type="number" id="collectDuration" value="10" min="1" class="w-20 border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
            </div>

            <button id="startButton" class="bg-green-500 hover:bg-green-600 text-white font-semibold rounded-md shadow" disabled>Start Collection</button>
            <button id="stopButton" class="bg-red-500 hover:bg-red-600 text-white font-semibold rounded-md shadow" disabled>Stop Collection</button>

            <div class="flex items-center gap-2">
                <label for="liveVizSelect" class="text-sm font-medium text-gray-600">Live View:</label>
                <select id="liveVizSelect" class="border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                    <option value="centeredStrips" selected>Centered Strips</option>
                    <option value="particleEmitters">Particle Emitters</option>
                    <option value="none">None</option>
                    <!-- Add more live viz options here later -->
                </select>
            </div>

            <div class="flex items-center gap-2">
                <label for="vizSelect" class="text-sm font-medium text-gray-600">Final Visualization:</label>
                <select id="vizSelect" class="border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                    <option value="lines">Line Graph</option>
                    <option value="circles">Circular Plot</option>
                    <option value="radial">Radial Bars</option>
                    <option value="stackedBars">Stacked Bars</option>
                    <option value="histogram">Histogram (Stream 1)</option>
                    <option value="heatmap">Heatmap</option>
                </select>
            </div>
        </div>

        <div id="status" class="status-indicator status-disconnected text-center mb-4">Status: Disconnected</div>
        <div id="errorDisplay" class="status-indicator status-error text-center mb-4" style="display: none;">Error: None</div>
        <div id="dataCount" class="text-center text-sm text-gray-500 mb-4">Data points collected: 0</div>


        <div id="canvasContainer" class="border rounded-md overflow-hidden shadow">
            </div>
    </div>

    <script>
        // --- Global Variables ---
        let port; // Serial port object
        let reader; // Serial port reader
        let keepReading = false; // Flag to control the reading loop
        let incomingBuffer = ''; // Buffer for incomplete serial lines

        let isCollecting = false; // Flag for data collection state
        let collectionStartTime;
        let collectionTimerId;
        let collectedData = []; // Array to store collected data [[val1, val2,...], [val1, val2,...]]
        let expectedDataLength = -1; // To store the number of values per line, determined by first valid data line

        let p5Instance; // To hold the p5 sketch instance
        let currentVisualization = 'lines'; // Default FINAL visualization
        let currentLiveVisualization = 'centeredStrips'; // Default LIVE visualization

        // --- UI Elements ---
        const connectButton = document.getElementById('connectButton');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const collectDurationInput = document.getElementById('collectDuration');
        const liveVizSelect = document.getElementById('liveVizSelect');
        const vizSelect = document.getElementById('vizSelect');
        const statusDiv = document.getElementById('status');
        const errorDiv = document.getElementById('errorDisplay');
        const dataCountDiv = document.getElementById('dataCount');
        const canvasContainer = document.getElementById('canvasContainer');

        // --- Utility Functions ---
        function updateStatus(message, type) {
            statusDiv.textContent = `Status: ${message}`;
            statusDiv.className = `status-indicator text-center mb-4 status-${type}`; // Update class for styling
        }

        function showError(message) {
            console.error(message);
            errorDiv.textContent = `Error: ${message}`;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            errorDiv.style.display = 'none';
        }

        function updateDataCount() {
            dataCountDiv.textContent = `Data points collected: ${collectedData.length}`;
        }

        function updateButtonStates() {
            const isConnected = port && port.readable;
            connectButton.disabled = isConnected;
            startButton.disabled = !isConnected || isCollecting;
            stopButton.disabled = !isCollecting;
            collectDurationInput.disabled = isCollecting;
        }

        // --- Serial Communication ---
        async function connectSerial() {
            hideError();
            if ('serial' in navigator) {
                try {
                    updateStatus('Requesting port...', 'collecting');
                    port = await navigator.serial.requestPort();
                    await port.open({ baudRate: 9600 }); // Common baud rate, adjust if needed

                    updateStatus('Connected', 'connected');
                    keepReading = true;
                    readLoop(); // Start the reading loop
                    updateButtonStates();

                } catch (err) {
                    updateStatus('Connection failed', 'error');
                    showError(`Could not connect: ${err.message}`);
                    port = null;
                    updateButtonStates();
                }
            } else {
                updateStatus('Web Serial API not supported', 'error');
                showError('Your browser does not support the Web Serial API. Try Chrome or Edge.');
            }
        }

        async function readLoop() {
            if (!port || !port.readable) {
                console.warn("Port not available or closed.");
                keepReading = false;
                updateStatus('Disconnected', 'disconnected');
                updateButtonStates();
                return;
            }

            // Use TextDecoderStream for easier text handling
            const textDecoder = new TextDecoderStream();
            const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();

            updateStatus('Reading data...', 'connected');

            try {
                while (keepReading) {
                    const { value, done } = await reader.read();
                    if (done) {
                        // Allow the serial port to be closed later.
                        reader.releaseLock();
                        break;
                    }
                    if (value) {
                        // Process the incoming chunk
                        processIncomingData(value);
                    }
                }
            } catch (error) {
                console.error('Error during reading:', error);
                showError(`Read error: ${error.message}`);
                updateStatus('Read error', 'error');
                // Attempt to clean up
                try {
                   await reader.cancel();
                   reader.releaseLock(); // Release lock on error
                } catch (cancelError) {
                    console.error('Error cancelling reader:', cancelError);
                }
                // Don't close the port here immediately, let disconnect handle it
                // await disconnectSerial(); // Maybe disconnect on read error?
            } finally {
                 // Ensure the lock is always released if the loop terminates unexpectedly
                if (reader && !reader.closed) {
                    try {
                        reader.releaseLock();
                    } catch(e) {
                        console.warn("Error releasing reader lock in finally:", e);
                    }
                }
            }
             // If keepReading became false, it means disconnect was called.
             // If the loop exited due to 'done', the port might have closed.
            if (!keepReading) {
                await disconnectSerial(); // Ensure cleanup if disconnect was initiated
            } else {
                 updateStatus('Reading stopped (port closed?)', 'disconnected');
                 updateButtonStates();
            }
        }

        function processIncomingData(chunk) {
            incomingBuffer += chunk;
            let newlineIndex;

            // Process buffer line by line
            while ((newlineIndex = incomingBuffer.indexOf('\n')) >= 0) {
                const line = incomingBuffer.substring(0, newlineIndex).trim(); // Get line, remove trailing \r if present
                incomingBuffer = incomingBuffer.substring(newlineIndex + 1); // Remove processed line from buffer

                if (line) { // Only process non-empty lines
                    parseAndStoreData(line);
                }
            }
            // Keep any remaining partial line in the buffer for the next chunk
        }

        function parseAndStoreData(line) {
             //console.log("Received line:", line); // Debugging
            try {
                const values = line.split(',')
                                   .map(val => val.trim()) // Trim whitespace
                                   .filter(val => val !== '') // Filter out empty strings potentially caused by trailing commas
                                   .map(Number); // Convert to numbers

                // Basic validation: Check if all are numbers and within range 0-360
                const isValid = values.every(v => !isNaN(v) && v >= 0 && v <= 360);

                if (!isValid) {
                    console.warn("Invalid data received:", line, values);
                    return; // Skip invalid lines silently or show a warning
                }

                // Determine expected data length from the first valid line during collection
                if (isCollecting && expectedDataLength === -1 && values.length > 0) {
                    expectedDataLength = values.length;
                    console.log(`Determined expected data length: ${expectedDataLength}`);
                }

                // Store data only if collecting and matches expected length (if set)
                if (isCollecting) {
                     if (expectedDataLength === -1 || values.length === expectedDataLength) {
                        collectedData.push(values);
                        updateDataCount();
                     } else {
                         console.warn(`Data length mismatch. Expected ${expectedDataLength}, got ${values.length}. Line: "${line}"`);
                     }
                }

            } catch (parseError) {
                console.error("Error parsing line:", line, parseError);
                // Optionally show a persistent error or warning
            }
        }


        async function disconnectSerial() {
            keepReading = false; // Signal the read loop to stop

            if (reader) {
                try {
                    await reader.cancel(); // Cancel any pending reads
                    // The releaseLock should happen in the readLoop's finally block
                } catch (err) {
                    console.error('Error cancelling reader:', err);
                    showError(`Error cancelling reader: ${err.message}`);
                }
                reader = null;
            }

            if (port && port.readable) {
                 // The read loop should release the lock. Wait a moment just in case.
                await new Promise(resolve => setTimeout(resolve, 100));
                try {
                    await port.close();
                    console.log("Serial port closed.");
                } catch (err) {
                    console.error('Error closing port:', err);
                     // Ignore errors if the port is already closed or closing.
                    if (!err.message.includes("port is already closed")) {
                       showError(`Error closing port: ${err.message}`);
                    }
                }
            }

            port = null;
            updateStatus('Disconnected', 'disconnected');
            updateButtonStates();
        }


        // --- Data Collection ---
        function startCollection() {
            if (!port || !port.readable) {
                showError("Not connected to a serial device.");
                return;
            }
            if (isCollecting) return; // Already collecting

            hideError();
            collectedData = []; // Clear previous data
            expectedDataLength = -1; // Reset expected length
            updateDataCount();
            isCollecting = true;
            collectionStartTime = Date.now(); // Record start time accurately
            const durationSeconds = parseInt(collectDurationInput.value, 10);
            const durationMs = durationSeconds * 1000;

            updateStatus(`Collecting data for ${durationSeconds}s...`, 'collecting');
            updateButtonStates();

            // Stop collection after the specified duration
            clearTimeout(collectionTimerId); // Clear any previous timer
            collectionTimerId = setTimeout(stopCollection, durationMs);

            // Prepare p5 canvas and particle system for live drawing
            if (p5Instance) {
                 // Clear particles regardless of visualization type
                 if (p5Instance.sketchInstanceVariables && typeof p5Instance.sketchInstanceVariables.clearParticles === 'function') {
                    p5Instance.sketchInstanceVariables.clearParticles();
                 }

                 // Set initial background based on selected live visualization
                 if (currentLiveVisualization === 'particleEmitters') {
                    p5Instance.background(0, 0, 10); // Dark background for particles
                 } else {
                    p5Instance.background(240); // Default light grey for others (like strips)
                 }
                 p5Instance.loop(); // Start the p5 draw loop
            }
        }

        function stopCollection() {
            if (!isCollecting) return; // Not collecting

            isCollecting = false;
            clearTimeout(collectionTimerId); // Clear timer in case stopped manually
            const collectionEndTime = Date.now();
            const actualDuration = ((collectionEndTime - collectionStartTime) / 1000).toFixed(1);

            updateStatus(`Collection finished (${actualDuration}s). ${collectedData.length} points captured.`, 'finished');
            updateButtonStates();

            // Stop the p5 draw loop and trigger a final draw for the selected post-collection visualization
            if (p5Instance) {
                p5Instance.noLoop();
                p5Instance.redraw(); // Redraw one last time with the selected visualization
            }
        }

        // --- P5 Sketch Definition ---
        const sketch = (p) => {
            let canvasWidth = 600;
            let canvasHeight = 400;

            // Store sketch-specific variables/functions needed externally
            // Note: This is a slight workaround for accessing sketch state from global functions
            p.sketchInstanceVariables = {
                 particles: [],
                 clearParticles: () => { p.sketchInstanceVariables.particles = []; }
            };
            let particles = p.sketchInstanceVariables.particles; // Local reference

            // Simple Particle class (or object structure)
            class Particle {
                constructor(x, y, vx, vy, lifespan, col) {
                    this.pos = p.createVector(x, y);
                    this.vel = p.createVector(vx, vy);
                    this.lifespan = lifespan; // Frames
                    this.initialLifespan = lifespan;
                    this.col = col; // p5.color object
                }

                update() {
                    this.pos.add(this.vel);
                    this.lifespan -= 1;
                }

                display() {
                    // Fade out as lifespan decreases
                    let alpha = p.map(this.lifespan, 0, this.initialLifespan, 0, 255);
                    // Use HSB components from the stored color, but adjust alpha
                    p.fill(p.hue(this.col), p.saturation(this.col), p.brightness(this.col), alpha / 255); // p5 alpha is 0-1 in HSB
                    p.noStroke();
                    p.ellipse(this.pos.x, this.pos.y, 8, 8); // Draw particle as a small circle
                }

                isDead() {
                    return this.lifespan <= 0;
                }
            }


            // Visualization functions are defined within the sketch scope
            const visualizations = {
                lines: (data) => {
                    p.stroke(0, 100, 200, 150); // Blueish lines
                    p.strokeWeight(1);
                    p.noFill();

                    if (data.length === 0 || data[0].length === 0) return; // No data

                    const numLines = data[0].length;
                    const spacing = p.width / (data.length -1 || 1); // Avoid division by zero if only 1 point

                    for (let j = 0; j < numLines; j++) {
                        p.beginShape();
                        for (let i = 0; i < data.length; i++) {
                            const x = i * spacing;
                            // Map data value (0-360) to canvas height (with padding)
                            const y = p.map(data[i][j] || 0, 0, 360, p.height - 20, 20); // Use || 0 for safety
                            p.vertex(x, y);
                        }
                        p.endShape();
                    }
                     // Draw axes/labels (optional)
                    p.stroke(150);
                    p.strokeWeight(0.5);
                    p.line(0, p.height - 20, p.width, p.height - 20); // X-axis (bottom)
                    p.line(0, 20, p.width, 20); // Top guide
                    p.textAlign(p.LEFT, p.CENTER);
                    p.noStroke();
                    p.fill(100);
                    p.text('0', 5, p.height - 20);
                    p.text('360', 5, 20);
                },

                circles: (data) => {
                    p.noStroke();
                    if (data.length === 0 || data[0].length === 0) return;

                    const numStreams = data[0].length;
                    const maxRadius = p.min(p.width, p.height) / 2 * 0.8; // Max radius for largest circle
                    const centerX = p.width / 2;
                    const centerY = p.height / 2;

                    // Use the *last* data point for the visualization
                    const lastDataPoint = data[data.length - 1];

                    for (let i = 0; i < numStreams; i++) {
                        const value = lastDataPoint[i] || 0;
                        const radius = p.map(value, 0, 360, 0, maxRadius);
                        // Assign different colors based on index
                        p.fill((i * 60) % 255, 150, 200, 100); // Vary hue, semi-transparent
                        p.ellipse(centerX, centerY, radius * 2, radius * 2);
                    }
                     // Add labels (optional)
                    p.fill(0);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text(`Last reading: ${lastDataPoint.map(v => v.toFixed(0)).join(', ')}`, centerX, p.height - 20);
                },
                radial: (data) => {
                    p.strokeWeight(2);
                    if (data.length === 0 || data[0].length === 0) return;

                    const numStreams = data[0].length;
                    const centerX = p.width / 2;
                    const centerY = p.height / 2;
                    const maxLen = p.min(p.width, p.height) / 2 * 0.8;
                    const angleStep = p.TWO_PI / data.length; // Angle per data point over time

                    for (let j = 0; j < numStreams; j++) {
                        // Assign color based on stream index
                        p.stroke((j * 70) % 360, 80, 70); // HSB color mode

                        for (let i = 0; i < data.length; i++) {
                            const value = data[i][j] || 0;
                            const len = p.map(value, 0, 360, 0, maxLen);
                            const angle = i * angleStep - p.HALF_PI; // Start from top

                            const x = centerX + p.cos(angle) * len;
                            const y = centerY + p.sin(angle) * len;

                            // Draw a line from center to point for each reading
                            p.line(centerX, centerY, x, y);
                        }
                    }
                },
                stackedBars: (data) => {
                    p.noStroke();
                    if (data.length === 0 || data[0].length === 0) return;

                    const numDataPoints = data.length;
                    const numStreams = data[0].length;
                    const barWidth = p.width / numDataPoints;
                    const maxPossibleTotalValue = numStreams * 360; // Assuming max value per sensor is 360

                    for (let i = 0; i < numDataPoints; i++) {
                        let currentY = p.height; // Start drawing from the bottom
                        let totalValue = 0;
                        // Calculate total value for this time step first
                        for (let j = 0; j < numStreams; j++) {
                            totalValue += data[i][j] || 0;
                        }

                        // Map the total value to the bar's total height
                        const totalBarHeight = p.map(totalValue, 0, maxPossibleTotalValue, 0, p.height);

                        // Now draw segments, scaling them relative to the totalBarHeight
                        let segmentStartY = p.height;
                        for (let j = 0; j < numStreams; j++) {
                            const value = data[i][j] || 0;
                            // Calculate segment height as a proportion of the totalBarHeight
                            const segmentHeight = (totalValue > 0) ? (value / totalValue) * totalBarHeight : 0;

                            // Assign color based on stream index (using HSB)
                            p.fill((j * (360 / (numStreams + 1))) % 360, 80, 90); // Spread hues

                            // Draw the rectangle segment
                            p.rect(i * barWidth, segmentStartY - segmentHeight, barWidth, segmentHeight);

                            // Update the starting Y for the next segment
                            segmentStartY -= segmentHeight;
                        }
                    }

                    // Optional: Add labels or legend
                    p.fill(50); // Dark grey text
                    p.textAlign(p.LEFT, p.TOP); // Align to top left
                    p.text(`Showing ${numDataPoints} time steps as stacked bars.`, 5, 5); // Position at top left
                },
                histogram: (data) => {
                    p.stroke(100); // Light grey border for bars
                    p.strokeWeight(0.5);
                    if (data.length === 0 || data[0].length === 0) {
                        p.fill(150);
                        p.noStroke();
                        p.textAlign(p.CENTER, p.CENTER);
                        p.text('No data for histogram.', p.width / 2, p.height / 2);
                        return;
                    }

                    const numBins = 12; // How many bins to divide 0-360 into (e.g., 12 bins of 30 degrees)
                    const binWidthValue = 360 / numBins; // The range of values each bin covers
                    let binCounts = new Array(numBins).fill(0); // Initialize counts to zero

                    // --- Data Processing: Count values into bins ---
                    // We'll analyze the *first* data stream (index 0)
                    for (let i = 0; i < data.length; i++) {
                        const value = data[i][0] || 0; // Get value from the first stream
                        // Ensure value is within expected range (clamp just in case)
                        const clampedValue = p.constrain(value, 0, 359.999); // Use 359.999 to keep 360 out of bounds for bin index calc
                        const binIndex = Math.floor(clampedValue / binWidthValue);
                        if (binIndex >= 0 && binIndex < numBins) {
                            binCounts[binIndex]++;
                        } else {
                             console.warn(`Value ${value} resulted in unexpected bin index ${binIndex}`);
                        }
                    }

                    // --- Drawing ---
                    let maxCount = 0;
                    for (let count of binCounts) {
                        if (count > maxCount) {
                            maxCount = count;
                        }
                    }

                    if (maxCount === 0) {
                         p.fill(150);
                         p.noStroke();
                         p.textAlign(p.CENTER, p.CENTER);
                         p.text('No data points found in the expected range for Stream 1.', p.width / 2, p.height / 2);
                         return;
                    }

                    const barWidthPixels = p.width / numBins;
                    p.fill(0, 80, 80); // Use HSB color (Reddish)

                    for (let b = 0; b < numBins; b++) {
                        // Map the count in this bin to a height on the canvas
                        // Map range [0, maxCount] to [0, p.height]
                        const barHeight = p.map(binCounts[b], 0, maxCount, 0, p.height);

                        const x = b * barWidthPixels;
                        const y = p.height - barHeight; // Y position starts from bottom

                        p.rect(x, y, barWidthPixels, barHeight);

                        // Optional: Add labels for bins
                        p.fill(50); // Dark text
                        p.noStroke();
                        p.textAlign(p.CENTER, p.BOTTOM);
                        const binStart = Math.round(b * binWidthValue);
                        const binEnd = Math.round((b + 1) * binWidthValue);
                        // Only draw label if bar has some width
                        if (barWidthPixels > 20) {
                             p.text(`${binStart}-${binEnd}`, x + barWidthPixels / 2, p.height - 5);
                        }
                         p.fill(0, 80, 80); // Reset fill for next bar
                         p.stroke(100); // Reset stroke for next bar
                    }

                     // Add overall title/info
                     p.fill(50);
                     p.noStroke();
                     p.textAlign(p.LEFT, p.TOP);
                     p.text(`Histogram of Stream 1 values (${data.length} points, max count: ${maxCount})`, 5, 5);
                },
                heatmap: (data) => {
                    p.noStroke(); // No borders for the cells initially
                    if (data.length === 0 || data[0].length === 0) {
                        p.fill(150);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.text('No data for heatmap.', p.width / 2, p.height / 2);
                        return;
                    }

                    const numTimeSteps = data.length;
                    const numStreams = data[0].length;

                    // Calculate the size of each cell to fit the canvas
                    const cellWidth = p.width / numTimeSteps;
                    const cellHeight = p.height / numStreams;

                    // --- Draw the heatmap cells ---
                    for (let i = 0; i < numTimeSteps; i++) { // Iterate through time (columns)
                        for (let j = 0; j < numStreams; j++) { // Iterate through streams (rows)
                            const value = data[i][j] || 0;

                            // Map the value (0-360) to a color hue (e.g., blue to red)
                            // Using HSB: Hue from 240 (blue) down to 0 (red)
                            const hue = p.map(value, 0, 360, 240, 0);
                            p.fill(hue, 90, 90); // Saturation and Brightness set to 90

                            // Calculate position
                            const x = i * cellWidth;
                            const y = j * cellHeight;

                            // Draw the rectangle cell
                            p.rect(x, y, cellWidth, cellHeight);
                        }
                    }

                    // --- Optional: Add labels or grid lines if cells are large enough ---
                    if (cellHeight > 15) { // Only add stream labels if cells are tall enough
                        p.fill(0); // Black text
                        p.textAlign(p.LEFT, p.CENTER);
                        p.textSize(p.constrain(cellHeight * 0.6, 8, 14)); // Scale text size
                        for (let j = 0; j < numStreams; j++) {
                            p.text(`S${j+1}`, 5, j * cellHeight + cellHeight / 2);
                        }
                    }
                     if (cellWidth > 30) { // Only add time labels if cells are wide enough
                         p.fill(0);
                         p.textAlign(p.CENTER, p.TOP);
                         p.textSize(p.constrain(cellWidth * 0.2, 8, 12));
                         for (let i = 0; i < numTimeSteps; i+= Math.max(1, Math.floor(numTimeSteps/10))) { // Label ~10 steps
                             p.text(`${i}`, i * cellWidth + cellWidth / 2, 5);
                         }
                     }

                     // Add overall title
                     p.fill(50);
                     p.noStroke();
                     p.textAlign(p.CENTER, p.BOTTOM);
                     p.textSize(12);
                     p.text(`Heatmap: ${numStreams} streams over ${numTimeSteps} time steps`, p.width / 2, p.height - 5);
                }
            };

            p.setup = () => {
                // Dynamically determine canvas size based on container?
                // For now, fixed size.
                canvasWidth = canvasContainer.offsetWidth > 100 ? canvasContainer.offsetWidth : 600; // Ensure minimum width
                canvasHeight = 400;
                let cnv = p.createCanvas(canvasWidth, canvasHeight);
                cnv.parent('canvasContainer'); // Attach canvas to the div
                p.colorMode(p.HSB, 360, 100, 100, 1.0); // Use HSB for easier color manipulation
                p.noLoop(); // Start paused
                p.background(0, 0, 10); // Dark background initially
                p.textAlign(p.CENTER, p.CENTER);
                p.fill(0, 0, 80);
                p.text('Connect device and collect data to visualize.', p.width / 2, p.height / 2);
            };

            p.draw = () => {
                 particles = p.sketchInstanceVariables.particles; // Ensure local reference is up-to-date

                 if (isCollecting) {
                     // --- Live Visualization Logic ---
                     // Check if we have *any* data and if expectedDataLength has been determined
                     if (collectedData.length === 0 || expectedDataLength <= 0) {
                         // Optionally display a waiting message, but ensure no drawing commands interfere
                         // Example: Draw only text if waiting
                         // p.fill(150); p.noStroke();
                         // p.text("Waiting for data...", p.width/2, p.height/2);
                         return; // Wait for the first valid data point AND expected length
                     }

                     const latestData = collectedData[collectedData.length - 1];
                     // Additional check: Ensure latestData matches expected length
                     if (!latestData || latestData.length !== expectedDataLength) {
                        console.warn("Data mismatch or not ready, skipping frame.");
                        return; // Skip frame if data isn't consistent yet
                     }

                     // Now we know expectedDataLength > 0 and latestData is valid
                     const numStreams = expectedDataLength; // Can safely use numStreams now if preferred
                     const durationSeconds = parseInt(collectDurationInput.value, 10);
                     const durationMs = durationSeconds * 1000;
                     const elapsedMs = Date.now() - collectionStartTime;
                     const progress = p.constrain(elapsedMs / durationMs, 0, 1);

                     // --- Select live visualization based on dropdown ---
                     switch (currentLiveVisualization) {
                         case 'centeredStrips':
                             // --- Centered Strips Logic ---
                             // **NO p.background() call here**
                             const currentY = p.map(progress, 0, 1, p.height, 0);
                             const boxHeight = 2;

                             let totalActualWidth = 0;
                             let actualBoxWidths = [];
                             // Use numStreams (which is confirmed > 0 expectedDataLength here)
                             const maxBoxWidthPerStream = p.width / numStreams;

                             for (let j = 0; j < numStreams; j++) {
                                 const value = latestData[j] || 0;
                                 const boxWidth = p.map(value, 0, 360, 0, maxBoxWidthPerStream);
                                 actualBoxWidths.push(boxWidth);
                                 totalActualWidth += boxWidth;
                             }

                             let startX = (p.width - totalActualWidth) / 2;
                             let currentX = startX;

                             p.noStroke();
                             for (let j = 0; j < numStreams; j++) {
                                 const value = latestData[j] || 0;
                                 const boxWidth = actualBoxWidths[j];
                                 const hue = p.map(value, 0, 360, 240, 0);
                                 p.fill(hue, 90, 90); // Set fill for this strip segment
                                 if (boxWidth > 0) {
                                     p.rect(currentX, currentY - boxHeight, boxWidth, boxHeight);
                                 }
                                 currentX += boxWidth;
                             }
                             break; // End of centeredStrips case

                         case 'particleEmitters':
                              // --- Particle Emitter Logic ---
                              p.background(0, 0, 10, 0.1); // Trail effect

                              // Use a distinct variable name for clarity
                              const numEmitterStreams = latestData.length; // Should equal numStreams here

                              for (let j = 0; j < numEmitterStreams; j++) {
                                  const value = latestData[j] || 0;
                                  const emitterX = p.map(j, 0, numEmitterStreams - 1 || 1, p.width * 0.1, p.width * 0.9);
                                  const emitterY = p.height / 2;
                                  const emissionRate = p.map(value, 0, 360, 0, 3);
                                  const hue = p.map(value, 0, 360, 240, 0);
                                  const col = p.color(hue, 90, 90);
                                  const initialSpeed = 2;
                                  const lifespan = 80;

                                  for (let i = 0; i < emissionRate; i++) {
                                      let angle = p.random(p.TWO_PI);
                                      let vx = p.cos(angle) * initialSpeed;
                                      let vy = p.sin(angle) * initialSpeed;
                                      p.sketchInstanceVariables.particles.push(new Particle(emitterX, emitterY, vx, vy, lifespan, col));
                                  }
                              }

                              // Update and display all particles
                              for (let i = p.sketchInstanceVariables.particles.length - 1; i >= 0; i--) {
                                  p.sketchInstanceVariables.particles[i].update();
                                  p.sketchInstanceVariables.particles[i].display();
                                  if (p.sketchInstanceVariables.particles[i].isDead()) {
                                      p.sketchInstanceVariables.particles.splice(i, 1);
                                  }
                              }
                              break; // End of particleEmitters case

                         case 'none':
                             // --- None Logic ---
                              // **If this case is selected, need to ensure background is cleared**
                              // Because 'centeredStrips' doesn't clear it.
                              p.background(240); // Clear to default background color for 'none'
                              p.noStroke();
                              p.fill(0, 0, 80);
                              p.rect(0, p.height - 5, p.width, 5);
                              p.fill(120, 80, 80);
                              p.rect(0, p.height - 5, p.width * progress, 5);
                              break; // End of none case

                         default:
                            // **Also ensure background is cleared here if needed**
                            p.background(240); // Clear for unknown viz state too
                            p.fill(0);
                            p.textAlign(p.CENTER, p.CENTER);
                            p.text(`Unknown live viz: ${currentLiveVisualization}`, p.width/2, p.height/2);

                     } // End switch

                 } else if (collectedData.length > 0) {
                     // --- Post-Collection Logic ---
                     p.background(255); // Clear background for final visualization
                     if (visualizations[currentVisualization]) {
                        try {
                            visualizations[currentVisualization](collectedData);
                        } catch(visError) {
                             console.error(`Error in visualization '${currentVisualization}':`, visError);
                             p.fill(255,0,0); // Red for error
                             p.noStroke();
                             p.textAlign(p.CENTER, p.CENTER);
                             p.text(`Error rendering visualization: ${visError.message}`, p.width/2, p.height/2);
                        }
                     } else {
                        p.fill(200, 0, 0); // Indicate error - unknown viz
                        p.noStroke();
                        p.textAlign(p.CENTER, p.CENTER);
                        p.text(`Unknown visualization: ${currentVisualization}`, p.width / 2, p.height / 2);
                     }
                 } else {
                    // --- Initial State Logic ---
                    p.background(0, 0, 10); // Dark background before connection/collection
                    p.fill(0, 0, 80);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text('Connect device and collect data to visualize.', p.width / 2, p.height / 2);
                 }
            }; // End p.draw

             // Custom function to clear canvas, called before starting collection
            p.clearCanvas = () => {
                p.background(255); // Clear with white
                p.fill(180);
                p.noStroke();
                p.textAlign(p.CENTER, p.CENTER);
                p.text('Ready to collect data...', p.width / 2, p.height / 2);
                // p.redraw(); // Redraw immediately to show the cleared state
            };

            // Optional: Handle window resize
            p.windowResized = () => {
                 canvasWidth = canvasContainer.offsetWidth > 100 ? canvasContainer.offsetWidth : 600;
                 p.resizeCanvas(canvasWidth, canvasHeight); // Adjust height if needed too
                 // Don't redraw if collecting, let the loop handle it
                 if (!isCollecting) {
                    p.redraw();
                 }
            };
        };

        // --- Event Listeners ---
        connectButton.addEventListener('click', async () => {
            if (port) {
                await disconnectSerial(); // Disconnect if already connected (button logic should prevent this state ideally)
            } else {
                await connectSerial();
            }
             // Re-initialize p5 if needed, or ensure it's ready
            if (!p5Instance) {
                 p5Instance = new p5(sketch);
            } else {
                 // If p5 already exists, maybe reset background/state
                 p5Instance.background(0, 0, 10);
                 p5Instance.fill(0, 0, 80);
                 p5Instance.textAlign(p5Instance.CENTER, p5Instance.CENTER);
                 p5Instance.text('Connect device and collect data to visualize.', p5Instance.width / 2, p5Instance.height / 2);
                 p5Instance.noLoop(); // Ensure it's paused
            }
        });

        // Ensure the global startCollection is called
        startButton.addEventListener('click', startCollection); // No arrow func needed now
        stopButton.addEventListener('click', stopCollection);

        liveVizSelect.addEventListener('change', (event) => {
            currentLiveVisualization = event.target.value;
            // REMOVED background clearing from here.
            // The initial background is set ONCE in startCollection.
            // The p.draw() loop handles background clearing PER FRAME only if needed (e.g., for particles).
        });

        vizSelect.addEventListener('change', (event) => {
            currentVisualization = event.target.value;
            if (p5Instance && collectedData.length > 0 && !isCollecting) {
                p5Instance.redraw(); // Redraw with the new visualization if data exists and not collecting
            } else if (p5Instance && !isCollecting) {
                 // Optionally clear or show default message if no data
                 p5Instance.clearCanvas(); // Or redraw to show 'no data' message for the new viz type
                 p.background(255);
                 p.fill(180);
                 p.noStroke();
                 p.textAlign(p.CENTER, p.CENTER);
                 p.text(`Switched to ${currentVisualization}. Collect data to view.`, p.width / 2, p.height / 2);

            }
        });

        // Initialize button states on load
        updateButtonStates();
        // Create p5 instance on load? Or wait for connect? Let's wait for connect.
        // p5Instance = new p5(sketch);

    </script>

</body>
</html>
